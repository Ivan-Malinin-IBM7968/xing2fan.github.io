<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F19%2FJPEG%2F</url>
    <content type="text"><![CDATA[JPEG编码 [jpeg官网]https://jpeg.org/JPEG是一种对数字图像进行有损压缩的常用方法，特别是对由数码摄影产生的图像。JPEG(Joint Photographic Experts Group)是在国际标准化组织(ISO)领导之下制定静态图像压缩标准的委员会，第一套国际静态图像压缩标准ISO 10918-1(JPEG)就是该委员会制定的。由于JPEG优良的品质，被广泛应用于互联网和数码相机领域，互联网上大多数的图像都采用了JPEG压缩标准，目前JPEG格式可以分为标准JPEG、渐进式JPEG和JPEG2000三种。 1.JPEG编码过程1.彩色空间转换和降采样首先，图像像素格式应该从RGB转换成YCBCR。它具有三个分量，其中Y分量表示像素的亮度，CB和CR分量表示色度和饱和度，在转换完成之后，还需要对YCBCR进行颜色分量的降采样，一般采用4:2:0格式。 # 2.DCT变换 #DCT（DiscreteConsineTransform）是将图像数据在频率域上分离出高频和低频信息的过程。然后再对图像的高频部分（即图像细节）进行压缩，以达到压缩图像数据的目的。在JPEG标准中首先将一帧图像划分为多个8*8的矩阵。然后对每一个矩阵作DCT变换。变换后将得到一个浮点频率系数矩阵。 # 3.量化 #由于JPEG在后续编码过程中使用的码本都是整数，因此需要对变换后的频率系数进行量化，将浮点数转换为整数。进行数据量化后，矩阵中的数据都是近似值，和原始图像数据之间有了差异，会造成图像压缩后失真。 # 4.编码 #编码采用两种机制：一种是0值的行程长度编码；二是熵编码（EntropyCoding）。在JPEG中，采用曲徊序列，即以矩阵对角线的法线方向作“之”字排列矩阵中的元素。这样做的优点是使得靠近矩阵左上角、值比较大的元素排列在行程的前面，而行程的后面所排列的矩阵元素基本上为0值。行程长度编码是非常简单和常用的编码方式，在此不再赘述。编码实际上是一种基于统计特性的编码方法。在JPEG中允许采用HUFFMAN编码或者算术编码。 2.JPEG图片格式详解JPEG文件大体上可以分成两个部分：标记码(Tag)和压缩数据。标记码由两个字节构成，其前一个字节是固定值0xFF，后一个字节则根据不同意义有不同数值。JPEG图片格式组成部分有：SOI（文件头）+APP0（图像识别信息）+ DQT（定义量化表）+ SOF0（图像基本信息）+ DHT（定义Huffman表） + DRI（定义重新开始间隔）+ SOS（扫描行开始）+ EOI（文件尾） SOI ：Start of Image，图像开始，标记代码2字节，固定值0xFFD8。APP0：Application，应用程序保留标记0，标记代码2字节固定值0xFFE0。DQT ：Define Quantization Table，定义量化表，标记代码2字节固定值0xFFDB。SOF0：Start of Frame，帧图像开始，标记代码2字节固定值0xFFC0。DHT ：Difine Huffman Table，定义哈夫曼表，标记代码2字节固定值0xFFC4。DRI ：Define Restart Interval，定义差分编码累计复位的间隔，标记代码2字节固定值0xFFDD。SOS ：Start of Scan，扫描开始12字节，标记代码2字节固定值0xFFDA。EOI ：End of Image，图像结束2字节，标记代码2字节固定值0xFFD9。 以上可以看出，在JPEG文件中0xFF具有标志意义，所以在压缩数据流(真正的图像信息)中出现0xFF，就需要作特别处理。具体方法是，在数据0xFF后添加一个没有意义的0x00。换句话说，如果在图像数据流中遇到0xFF，应该检测其紧接着的字符，如果是：1）0x00，则表示0xFF是图像流的组成部分，需要进行译码；2）0xD9，则与0xFF组成标记EOI，则图像流结束，同时图像文件结束；3）0xD0~0xD7,则组成RSTn标记，则要忽视整个RSTn标记，即不对当前0xFF和紧接的0xDn两个字节进行译码，并按RST标记的规则调整译码变量；3）0xFF，则忽视当前0xFF，对后一个0xFF再作判断；4）其他数值，则忽视当前0xFF，并保留紧接的此数值用于译码。 3.JPEG图像编码JPEG压缩编码算法的主要计算步骤如下：(0) 8*8分块。(1) 正向离散余弦变换(FDCT)。(2) 量化(quantization)。(3) Z字形编码(zigzag scan)。(4) 使用差分脉冲编码调制(DPCM)对直流系数(DC)进行编码。(5) 使用行程长度编码(RLE)对交流系数(AC)进行编码。(6) 熵编码。 4.JPEG图像解码4.1JPEG中的字节序 小端 = Little-Endians = Intel Mode：高字节保存在高地址中，低字节保存在低地址中。按我们书写的方向，低字节在右，高字节在左。大端 = Big-Endians = Motorola Mode：高字节保存在低地址中，低字节保存在高地址中。按我们书写的方向，高字节在右，低字节在左。 JPEG文件格式中，一个字（16位）的存储使用的是Motorola格式,即大端序，而不是Intel格式。也就是说, 一个字的高字节（高8位）在数据流的前面, 低字节（低8位）在数据流的后面，与平时习惯的Intel格式不一样。 5.注意5.1怎么决定文件是否是jpeg格式？用二进制形式打开图片文件，文件开始字节为FFD8，文件结束两字节为FFD9。则初步判定文件为jpeg。]]></content>
  </entry>
  <entry>
    <title><![CDATA[BMP文件格式]]></title>
    <url>%2F2019%2F03%2F09%2FBMP_FILE%2F</url>
    <content type="text"><![CDATA[1.BMP格式BMP格式是在windows系统中使用较多的一种图像文件格式。它可以完整的保存一幅图像所有像素数据。 BMP图像文件里面的数据从文件头开始可分为4个部分，各个部分如下： BMP文件头(BMP file header)：它提供文件的格式、大小等信息，一共14个字节。 位图信息头(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息，一共40个字节。 调色板(color palette)：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表。 位图数据(bitmap data)：就是图像裸数据。其中，是否含有调色板信息是根据BMP图像的位数(深度)决定的。比如，24位BMP和32位BMP不包含调色板部分，而对于8位BMP和16位BMP是需要调色板信息的。 在BMP图像文件中存储数据时，图像像素点数据的扫描方式是按从左到右、从下到上的顺序，存放格式是采用“小端序”，即低字节放低地址, 高字节放高地址。【举例】比如数字0x12 34 56 78在内存中的表示形式为：1)大端模式：低地址 ——————&gt; 高地址0x12 | 0x34 | 0x56 | 0x782)小端模式：低地址 ——————&gt; 高地址0x78 | 0x56 | 0x34 | 0x12具体内容可参见介绍大小端的博客文章：详解大端模式和小端模式. 2.BMP文件结构体/*14Bytes file header*/ typedef struct { u_int16_t bfType; u_int32_t bfSize; u_int16_t bfReserved1; u_int16_t bfReserved2; u_int32_t bfOffBits; }BITMAPFILEHEADER; /*40Bytes bmp mapinfo header*/ typedef struct { u_int32_t biSize; u_int32_t biWidth; u_int32_t biHeight; u_int16_t biPlanes; u_int16_t biBitCount; u_int32_t biCompression; u_int32_t biSizeImage; u_int32_t biXPelsPerMeter; u_int32_t biYPelsPerMeter; u_int32_t biClrUsed; u_int32_t biClrImportant; }BITMAPINFOHEADER; 若BITMAPINFOHEADER的成员biHeight为负值, 则表示BMP数据存储方向为从左到右, 从上到下；若BITMAPINFOHEADER的成员biHeight为正值, 则表示BMP数据存储方向为从左到右, 从下到上；此外，有时候可能需要将BMP图中的裸数据做BGR和RGB的转换，因为WINDOWS系统下多采用BGR，而有的平台或者系统可能会使用RGB,转换可以如下方式进行，即将每个像素点的红色分量和蓝色分量交换位置。 for(i = 0; i &lt; (w*h); i++) { temp = *(bmpBuff + i*3); *(bmpBuff + i*3) = *(bmpBuff + i*3 + 2); *(bmpBuff + i*3 + 2) = temp; } BMP图像格式还有一个非常重要的规定：要求每一扫描行的字节数据必须能被4整除，如果图像的一行字节数不能被4整除，就需要在每行的末尾补齐0以达到规定。因此，在我们的读取数据中需要根据BMP图像的宽度来判断是否被补0。 先判断一行的字节数是否可以被4整除，如果整除则不需要补0，如果没有整除，则求出补的0的个数，具体计算方法是： bu_0_number =4 - width(像素) * 3 % 4那么就知道在每一行的末尾都补了bu_0_number个0，因此我们在读取时绘制图片时就要忽略这些数据。 3.BMP文件读写时注意事项]]></content>
      <categories>
        <category>图片处理</category>
      </categories>
      <tags>
        <tag>图像 BMP - BMP - 图像</tag>
      </tags>
  </entry>
</search>
